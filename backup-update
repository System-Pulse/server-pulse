func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var (
		cmd  tea.Cmd
		cmds []tea.Cmd
	)

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		headerHeight := lipgloss.Height(m.renderHome()) + 2
		footerHeight := lipgloss.Height(m.renderFooter())
		verticalMargin := headerHeight + footerHeight
		m.viewport.Width = msg.Width
		m.viewport.Height = msg.Height - verticalMargin
		m.processTable.SetWidth(msg.Width)
		m.processTable.SetHeight(m.viewport.Height - 1)
		progWidth := min(max(msg.Width/3, 20), progressBarWidth)
		m.cpuProgress.Width = progWidth
		m.memProgress.Width = progWidth
		m.swapProgress.Width = progWidth
		for k, p := range m.diskProgress {
			p.Width = progWidth
			m.diskProgress[k] = p
		}

		if !m.ready {
			m.ready = true
		}
		return m, nil
	case tea.KeyMsg:
		// Gestion prioritaire du menu contextuel des conteneurs
		if m.containerMenuState == ContainerMenuVisible {
			switch msg.String() {
			case "up", "k":
				if m.selectedMenuItem > 0 {
					m.selectedMenuItem--
				}
				return m, nil
			case "down", "j":
				if m.selectedMenuItem < len(m.containerMenuItems)-1 {
					m.selectedMenuItem++
				}
				return m, nil
			case "enter":
				// Exécuter l'action sélectionnée
				if m.selectedMenuItem < len(m.containerMenuItems) {
					action := m.containerMenuItems[m.selectedMenuItem].Action
					switch action {
					case "open_single":
						m.containerViewState = ContainerViewSingle
						m.containerMenuState = ContainerMenuHidden
						m.containerTab = ContainerTabGeneral
						// Récupérer les détails du conteneur
						return m, m.loadContainerDetails(m.selectedContainer.ID)
					case "logs":
						// Afficher la vue des logs
						m.containerViewState = ContainerViewLogs
						m.containerMenuState = ContainerMenuHidden
						m.containerLogsLoading = true
						return m, m.app.GetContainerLogsCmd(m.selectedContainer.ID, "100")
					case "restart":
						// Demander confirmation avant redémarrage
						m.containerMenuState = ContainerMenuHidden
						m.confirmationVisible = true
						m.confirmationMessage = fmt.Sprintf("Restart container '%s'?\nThis will stop and start the container.", m.selectedContainer.Name)
						m.confirmationAction = "restart"
						m.confirmationData = m.selectedContainer.ID
						return m, nil
					case "delete":
						// Demander confirmation avant suppression
						m.containerMenuState = ContainerMenuHidden
						m.confirmationVisible = true
						m.confirmationMessage = fmt.Sprintf("Delete container '%s'?\nThis action cannot be undone.", m.selectedContainer.Name)
						m.confirmationAction = "delete"
						m.confirmationData = m.selectedContainer.ID
						return m, nil
					case "remove":
						// Demander confirmation avant suppression forcée
						m.containerMenuState = ContainerMenuHidden
						m.confirmationVisible = true
						m.confirmationMessage = fmt.Sprintf("Force remove container '%s'?\nThis action cannot be undone.", m.selectedContainer.Name)
						m.confirmationAction = "remove"
						m.confirmationData = m.selectedContainer.ID
						return m, nil
					case "toggle_start":
						// Démarrer/arrêter le conteneur
						m.containerMenuState = ContainerMenuHidden
						m.operationInProgress = true
						return m, m.app.ToggleContainerStateCmd(m.selectedContainer.ID)

					case "toggle_pause":
						// Pauser/reprendre le conteneur
						m.containerMenuState = ContainerMenuHidden
						m.operationInProgress = true
						return m, m.app.ToggleContainerPauseCmd(m.selectedContainer.ID)
					case "exec":
						// Ouvrir un shell dans le conteneur
						m.containerMenuState = ContainerMenuHidden
						m.pendingShellExec = &ShellExecRequest{ContainerID: m.selectedContainer.ID}
						m.shouldQuit = false
						return m, tea.Quit
					case "stats":
						// Afficher les statistiques en temps réel
						m.containerMenuState = ContainerMenuHidden
						m.containerViewState = ContainerViewSingle
						m.containerTab = ContainerTabCPU
						return m, m.app.GetContainerStatsCmd(m.selectedContainer.ID)
					case "inspect":
						// Afficher les informations d'inspection détaillées
						m.containerMenuState = ContainerMenuHidden
						m.containerViewState = ContainerViewSingle
						m.containerTab = ContainerTabGeneral
						return m, m.loadContainerDetails(m.selectedContainer.ID)
					case "commit":
						// Commiter le conteneur (à implémenter)
						m.containerMenuState = ContainerMenuHidden
						m.lastOperationMsg = "Commit functionality not yet implemented"
						return m, nil
					}
				}
				return m, nil
			case "o":
				m.containerViewState = ContainerViewSingle
				m.containerMenuState = ContainerMenuHidden
				m.containerTab = ContainerTabGeneral
				// Récupérer les détails du conteneur
				return m, m.loadContainerDetails(m.selectedContainer.ID)
			case "l":
				// Afficher la vue des logs
				m.containerViewState = ContainerViewLogs
				m.containerMenuState = ContainerMenuHidden
				m.containerLogsLoading = true
				return m, m.app.GetContainerLogsCmd(m.selectedContainer.ID, "100")
			case "r":
				// Demander confirmation avant redémarrage
				m.containerMenuState = ContainerMenuHidden
				m.confirmationVisible = true
				m.confirmationMessage = fmt.Sprintf("Restart container '%s'?\nThis will stop and start the container.", m.selectedContainer.Name)
				m.confirmationAction = "restart"
				m.confirmationData = m.selectedContainer.ID
				return m, nil
			case "d":
				// Demander confirmation avant suppression
				m.containerMenuState = ContainerMenuHidden
				m.confirmationVisible = true
				m.confirmationMessage = fmt.Sprintf("Delete container '%s'?\nThis action cannot be undone.", m.selectedContainer.Name)
				m.confirmationAction = "delete"
				m.confirmationData = m.selectedContainer.ID
				return m, nil
			case "x":
				// Demander confirmation avant suppression forcée
				m.containerMenuState = ContainerMenuHidden
				m.confirmationVisible = true
				m.confirmationMessage = fmt.Sprintf("Force remove container '%s'?\nThis action cannot be undone.", m.selectedContainer.Name)
				m.confirmationAction = "remove"
				m.confirmationData = m.selectedContainer.ID
				return m, nil
			case "s":
				// Démarrer/arrêter le conteneur
				m.containerMenuState = ContainerMenuHidden
				m.operationInProgress = true
				return m, m.app.ToggleContainerStateCmd(m.selectedContainer.ID)
			case "p":
				// Pauser/reprendre le conteneur
				m.containerMenuState = ContainerMenuHidden
				m.operationInProgress = true
				return m, m.app.ToggleContainerPauseCmd(m.selectedContainer.ID)
			case "e":
				// Ouvrir un shell dans le conteneur
				m.containerMenuState = ContainerMenuHidden
				m.pendingShellExec = &ShellExecRequest{ContainerID: m.selectedContainer.ID}
				m.shouldQuit = false
				return m, tea.Quit
			case "t":
				// Afficher les statistiques en temps réel
				m.containerMenuState = ContainerMenuHidden
				m.containerViewState = ContainerViewSingle
				m.containerTab = ContainerTabCPU
				return m, m.app.GetContainerStatsCmd(m.selectedContainer.ID)
			case "i":
				// Afficher les informations d'inspection détaillées
				m.containerMenuState = ContainerMenuHidden
				m.containerViewState = ContainerViewSingle
				m.containerTab = ContainerTabGeneral
				return m, m.loadContainerDetails(m.selectedContainer.ID)
			case "c":
				// Commiter le conteneur (à implémenter)
				m.containerMenuState = ContainerMenuHidden
				m.lastOperationMsg = "Commit functionality not yet implemented"
				return m, nil
			case "esc", "b":
				// Fermer le menu contextuel
				m.containerMenuState = ContainerMenuHidden
				m.selectedContainer = nil
				return m, nil
			case "q":
				return m, tea.Quit
			}
			// Si on est dans le menu, on ignore les autres touches
			return m, nil
		}

		// Gestion de la boîte de confirmation
		if m.confirmationVisible {
			switch msg.String() {
			case "y", "Y":
				// Confirmer l'action
				m.confirmationVisible = false
				switch m.confirmationAction {
				case "delete":
					if containerID, ok := m.confirmationData.(string); ok {
						m.operationInProgress = true
						m.confirmationAction = ""
						m.confirmationData = nil
						return m, m.app.DeleteContainerCmd(containerID, false)
					}
				case "remove":
					if containerID, ok := m.confirmationData.(string); ok {
						m.operationInProgress = true
						m.confirmationAction = ""
						m.confirmationData = nil
						return m, m.app.DeleteContainerCmd(containerID, true)
					}
				case "restart":
					if containerID, ok := m.confirmationData.(string); ok {
						m.operationInProgress = true
						m.confirmationAction = ""
						m.confirmationData = nil
						return m, m.app.RestartContainerCmd(containerID)
					}
				}
				return m, nil
			case "n", "N", "esc":
				// Annuler l'action
				m.confirmationVisible = false
				m.confirmationMessage = ""
				m.confirmationAction = ""
				m.confirmationData = nil
				return m, nil
			case "q":
				return m, tea.Quit
			}
			// Si on est dans la confirmation, ignorer les autres touches
			return m, nil
		}

		if m.searchMode {
			switch msg.String() {
			case "esc", "enter":
				var tcmd tea.Cmd
				m.searchMode = false
				m.processTable.Focus()
				m.container.Focus()
				if m.selectedMonitor == 1 {
					tcmd = m.updateProcessTable()
				} else {
					tcmd = m.app.UpdateApp()
				}
				return m, tcmd
			default:
				m.searchInput, cmd = m.searchInput.Update(msg)
				cmds = append(cmds, cmd)
				return m, tea.Batch(cmds...)
			}
		}

		// Scrolling/navigation
		if m.isMonitorActive && (m.selectedMonitor == 1 || m.selectedMonitor == 2) {
			switch msg.String() {
			case "up", "k":
				if m.selectedMonitor == 1 {
					m.processTable.MoveUp(0)
				} else {
					m.container.MoveUp(1)
				}
			case "down", "j":
				if m.selectedMonitor == 1 {
					m.processTable.MoveDown(0)
				} else {
					m.container.MoveDown(1)
				}
			case "pageup":
				if m.selectedMonitor == 1 {
					m.processTable.MoveUp(10)
				} else {
					m.container.MoveUp(10)
				}
			case "pagedown":
				if m.selectedMonitor == 1 {
					m.processTable.MoveDown(10)
				} else {
					m.container.MoveDown(10)
				}
			case "home":
				if m.selectedMonitor == 1 {
					m.processTable.GotoTop()
				} else {
					m.container.GotoTop()
				}
			case "end":
				if m.selectedMonitor == 1 {
					m.processTable.GotoBottom()
				} else {
					m.container.GotoBottom()
				}
			case "/":
				m.searchMode = true
				m.searchInput.Focus()
				return m, nil
			}
		} else if m.activeView != -1 {
			switch msg.String() {
			case "up", "k":
				m.viewport.ScrollUp(1)
			case "down", "j":
				m.viewport.ScrollDown(1)
			}
		}

		switch msg.String() {
		case "q", "ctrl+c":
			if m.pendingShellExec != nil {
				// On a une demande de shell en attente, ne pas quitter définitivement
				return m, tea.Quit
			} else {
				// Quitter définitivement
				m.shouldQuit = true
				return m, tea.Quit
			}
		case "enter":
			if m.activeView == -1 {
				m.activeView = m.selectedTab
				if m.activeView == 0 { // Monitor
					m.isMonitorActive = true
				}
			} else if m.isMonitorActive {
				// Si on est dans les conteneurs et qu'un conteneur est sélectionné
				if m.selectedMonitor == 2 && len(m.container.SelectedRow()) > 0 {
					// Récupérer le conteneur sélectionné
					selectedRow := m.container.SelectedRow()
					containerID := selectedRow[0]

					// Trouver le conteneur complet dans la liste
					containers, err := m.app.RefreshContainers()
					if err == nil {
						for _, container := range containers {
							if container.ID == containerID {
								m.selectedContainer = &container
								m.containerMenuState = ContainerMenuVisible
								m.selectedMenuItem = 0
								break
							}
						}
					} else {
						// En cas d'erreur, créer un conteneur minimal à partir des données de la table
						m.selectedContainer = &app.Container{
							ID:     containerID,
							Name:   selectedRow[2], // Name column
							Image:  selectedRow[1], // Image column
							Status: selectedRow[3], // Status column
						}
						m.containerMenuState = ContainerMenuVisible
						m.selectedMenuItem = 0
					}
				}
			}
		case "b", "esc":
			if m.searchMode {
				m.searchMode = false
				m.processTable.Focus()
			} else if m.containerViewState == ContainerViewSingle {
				// Retour de la vue détaillée vers la liste des conteneurs
				m.containerViewState = ContainerViewNone
				m.selectedContainer = nil
			} else if m.containerViewState == ContainerViewLogs {
				// Retour de la vue des logs vers la liste des conteneurs
				m.containerViewState = ContainerViewNone
				m.selectedContainer = nil
				m.containerLogs = ""
			} else if m.confirmationVisible {
				// Fermer la boîte de confirmation
				m.confirmationVisible = false
				m.confirmationMessage = ""
				m.confirmationAction = ""
				m.confirmationData = nil
			} else if m.containerMenuState == ContainerMenuVisible {
				// Fermer le menu contextuel
				m.containerMenuState = ContainerMenuHidden
				m.selectedContainer = nil
			} else if m.isMonitorActive {
				m.isMonitorActive = false
				m.activeView = -1
			} else if m.activeView != -1 {
				m.activeView = -1
			}
		case "tab", "right", "l":
			if m.containerViewState != ContainerViewSingle {

				if m.activeView == -1 {
					m.selectedTab = (m.selectedTab + 1) % len(m.tabs.DashBoard)
				} else if m.isMonitorActive {
					m.selectedMonitor = (m.selectedMonitor + 1) % len(m.tabs.Monitor)
				}
			}
		case "shift+tab", "left", "h":
			if m.containerViewState != ContainerViewSingle {
				if m.activeView == -1 {
					m.selectedTab = (m.selectedTab - 1 + len(m.tabs.DashBoard)) % len(m.tabs.DashBoard)
				} else if m.isMonitorActive {
					m.selectedMonitor = (m.selectedMonitor - 1 + len(m.tabs.Monitor)) % len(m.tabs.Monitor)
				}
			}
		case "1":
			if m.containerViewState != ContainerViewSingle && m.activeView == -1 {
				m.selectedTab = 0
			}
		case "2":
			if m.containerViewState != ContainerViewSingle && m.activeView == -1 {
				m.selectedTab = 1
			}
		case "3":
			if m.containerViewState != ContainerViewSingle && m.activeView == -1 {
				m.selectedTab = 2
			}
		case "4":
			if m.containerViewState != ContainerViewSingle && m.activeView == -1 {
				m.selectedTab = 3
			}
		case "k":
			if m.isMonitorActive && m.selectedMonitor == 1 && len(m.processTable.SelectedRow()) > 0 {
				selectedPID := m.processTable.SelectedRow()[0]
				pid, _ := strconv.Atoi(selectedPID)
				process, _ := os.FindProcess(pid)
				if process != nil {
					_ = process.Kill()
				}
				return m, proc.UpdateProcesses()
			}
		case "s":
			if m.isMonitorActive && m.selectedMonitor == 1 {
				sort.Slice(m.processes, func(i, j int) bool {
					return m.processes[i].CPU > m.processes[j].CPU
				})
				return m, m.updateProcessTable()
			}
		case "m":
			if m.isMonitorActive && m.selectedMonitor == 1 {
				sort.Slice(m.processes, func(i, j int) bool {
					return m.processes[i].Mem > m.processes[j].Mem
				})
				return m, m.updateProcessTable()
			}
		case "r":
			// Rafraîchir les logs si on est dans la vue des logs
			if m.containerViewState == ContainerViewLogs && m.selectedContainer != nil {
				m.containerLogsLoading = true
				return m, m.app.GetContainerLogsCmd(m.selectedContainer.ID, "100")
			}
		}

		// Gestion des onglets dans la vue détaillée du conteneur
		if m.containerViewState == ContainerViewSingle {
			switch msg.String() {
			case "tab", "right", "l":
				m.containerTab = ContainerTab((int(m.containerTab) + 1) % len(m.containerTabs))
			case "shift+tab", "left", "h":
				newTab := int(m.containerTab) - 1
				if newTab < 0 {
					newTab = len(m.containerTabs) - 1
				}
				m.containerTab = ContainerTab(newTab)
			case "1":
				m.containerTab = ContainerTabGeneral
			case "2":
				m.containerTab = ContainerTabCPU
			case "3":
				m.containerTab = ContainerTabMemory
			case "4":
				m.containerTab = ContainerTabNetwork
			case "5":
				m.containerTab = ContainerTabDisk
			case "6":
				m.containerTab = ContainerTabEnv
			}
		}

	case info.SystemMsg:
		m.system = info.SystemInfo(msg)
	case resource.CpuMsg:
		m.cpu = resource.CPUInfo(msg)
		cmds = append(cmds, m.cpuProgress.SetPercent(m.cpu.Usage/100))
	case resource.MemoryMsg:
		m.memory = resource.MemoryInfo(msg)
		cmds = append(cmds, m.memProgress.SetPercent(m.memory.Usage/100))
		cmds = append(cmds, m.swapProgress.SetPercent(m.memory.SwapUsage/100))
	case resource.DiskMsg:
		m.disks = []resource.DiskInfo(msg)
		for _, disk := range m.disks {
			if _, ok := m.diskProgress[disk.Mountpoint]; !ok && disk.Total > 0 {
				progOpts := []progress.Option{
					progress.WithWidth(m.cpuProgress.Width),
					progress.WithDefaultGradient(),
				}
				m.diskProgress[disk.Mountpoint] = progress.New(progOpts...)
			}
			if disk.Total > 0 {
				prog := m.diskProgress[disk.Mountpoint]
				cmds = append(cmds, prog.SetPercent(disk.Usage/100))
				m.diskProgress[disk.Mountpoint] = prog
			}
		}
	case resource.NetworkMsg:
		m.network = resource.NetworkInfo(msg)
	case proc.ProcessMsg:
		m.processes = []proc.ProcessInfo(msg)
		return m, m.updateProcessTable()

	case app.ContainerMsg:
		containers := []app.Container(msg)
		return m, m.updateContainerTable(containers)

	case app.ContainerDetailsMsg:
		details := app.ContainerDetails(msg)
		m.containerDetails = &details

	case app.ContainerLogsMsg:
		logsMsg := app.ContainerLogsMsg(msg)
		m.containerLogsLoading = false
		if logsMsg.Error != nil {
			m.containerLogs = fmt.Sprintf("Error loading logs: %v", logsMsg.Error)
		} else {
			m.containerLogs = logsMsg.Logs
		}

	case app.ContainerOperationMsg:
		opMsg := app.ContainerOperationMsg(msg)
		m.operationInProgress = false
		m.lastOperationMsg = utils.FormatOperationMessage(opMsg.Operation, opMsg.Success, opMsg.Error)

		// Rafraîchir la liste des conteneurs après une opération réussie
		var refreshCmd tea.Cmd
		if opMsg.Success {
			refreshCmd = m.app.UpdateApp()
		}

		// Effacer le message après 5 secondes
		return m, tea.Batch(refreshCmd, clearOperationMessage())

	case app.ExecShellMsg:
		// Handle shell execution request
		m.pendingShellExec = &ShellExecRequest{ContainerID: msg.ContainerID}
		m.shouldQuit = false
		return m, tea.Quit

	case app.ContainerStatsChanMsg:
		statsMsg := app.ContainerStatsChanMsg(msg)
		// Démarrer la collecte des statistiques en temps réel
		go m.handleRealTimeStats(statsMsg.ContainerID, statsMsg.StatsChan)
		return m, nil

	case ClearOperationMsg:
		m.lastOperationMsg = ""

	case utils.ErrMsg:
		m.err = msg
	case utils.TickMsg:
		cmds = append(cmds,
			tick(),
			info.UpdateSystemInfo(),
			resource.UpdateCPUInfo(),
			resource.UpdateMemoryInfo(),
			resource.UpdateDiskInfo(),
			resource.UpdateNetworkInfo(),
			proc.UpdateProcesses(),
			m.app.UpdateApp(),
		)
		// Mettre à jour les graphiques
		m.updateCharts()
	case progress.FrameMsg:
		var progCmd tea.Cmd
		var updatedModel tea.Model

		updatedModel, progCmd = m.cpuProgress.Update(msg)
		m.cpuProgress = updatedModel.(progress.Model)
		cmds = append(cmds, progCmd)

		updatedModel, progCmd = m.memProgress.Update(msg)
		m.memProgress = updatedModel.(progress.Model)
		cmds = append(cmds, progCmd)

		updatedModel, progCmd = m.swapProgress.Update(msg)
		m.swapProgress = updatedModel.(progress.Model)
		cmds = append(cmds, progCmd)

		for key, p := range m.diskProgress {
			updatedModel, progCmd := (p).Update(msg)

			newModel := updatedModel.(progress.Model)
			m.diskProgress[key] = newModel

			cmds = append(cmds, progCmd)
		}
	}

	if m.isMonitorActive && m.selectedMonitor == 1 {
		if !m.searchMode {
			m.processTable, cmd = m.processTable.Update(msg)
			cmds = append(cmds, cmd)
		}
	} else if m.activeView != -1 {
		m.viewport, cmd = m.viewport.Update(msg)
		cmds = append(cmds, cmd)
	}

	return m, tea.Batch(cmds...)
}